# LuaJIT -- interpreter and JIT compiler for Lua language.
# This is the main entry point for building, testing and packaging the project.
# Major portions taken verbatim or adapted from the uJIT.
# Copyright (C) 2015-2019 IPONWEB Ltd.

# --- Initial setup ------------------------------------------------------------
cmake_minimum_required(VERSION 2.8.12 FATAL_ERROR)
project(LUAJIT C)

#
# Fine-tuning cmake environment:
#

macro(append_flags flags)
  foreach(flag ${ARGN})
    set(${flags} "${${flags}} ${flag}")
  endforeach()
endmacro()

set(CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake")
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

include(SetVersion)

#
# Variables to be exported to child scopes:
#

SetVersion(
  LUAJIT_VERSION
  LUAJIT_VERSION_MAJOR
  LUAJIT_VERSION_MINOR
  LUAJIT_VERSION_PATCH
)

set(LUAJIT_SOURCE_DIR "${PROJECT_SOURCE_DIR}/src")
set(LUAJIT_BINARY_DIR "${PROJECT_BINARY_DIR}/src")

# Names of the CLI binaries
set(LUAJIT_CLI_NAME "luajit")

if(CMAKE_SYSTEM_NAME STREQUAL "SunOS" OR CMAKE_SYSTEM_NAME STREQUAL "PS3")
  set(BUILDMODE_VALUES static)
elseif(CMAKE_SYSTEM_NAME STREQUAL "Windows")
  set(BUILDMODE_VALUES dynamic static)
else()
  set(BUILDMODE_VALUES mixed static dynamic)
endif()
list(GET BUILDMODE_VALUES 0 BUILDMODE_DEFAULT)
set(BUILDMODE ${BUILDMODE_DEFAULT} CACHE STRING
  "Build mode. Choose one of the following: ${BUILDMODE_VALUES}."
)
set_property(CACHE BUILDMODE PROPERTY STRINGS ${BUILDMODE_VALUES})

message(STATUS "!WIP: BUILDMODE=${BUILDMODE}")

# Check that BUILDMODE value is correct
# In CMake 3.5 we'll be able to use IN_LIST here
list(FIND BUILDMODE_VALUES ${BUILDMODE} BUILDMODE_INDEX)
if(BUILDMODE_INDEX EQUAL -1)
  message(FATAL_ERROR "BUILDMODE must be one of the following: ${BUILDMODE_VALUES}.")
endif()

#
# --- Compilation flags setup --------------------------------------------------
#

if(CMAKE_INSTALL_PREFIX)
  append_flags(CMAKE_C_FLAGS -DLUA_ROOT='"${CMAKE_INSTALL_PREFIX}"')
endif()

if(CMAKE_LIBRARY_ARCHITECTURE)
  append_flags(CMAKE_C_FLAGS -DLUA_MULTILIB='"lib/${CMAKE_LIBRARY_ARCHITECTURE}"')
endif()

# Since the assembler part does NOT maintain a frame pointer, it's pointless
# to slow down the C part by not omitting it. Debugging, tracebacks and
# unwinding are not affected -- the assembler part has frame unwind
# information and GCC emits it where needed (x64) or with -g.
append_flags(CMAKE_C_FLAGS -fomit-frame-pointer)

# All symbols are hidden by default, public API is attributed with LUA*_API
# macros in both headers and translation units. See src/luaconf.h for details.
# FIXME: this flag leads to linkage issues with shared objects.
option(LUAJIT_HIDDEN_SYMBOLS "Hide all symbols that aren't external" ON)
if(LUAJIT_HIDDEN_SYMBOLS)
  append_flags(CMAKE_C_FLAGS -fvisibility=hidden)
endif()

# Enable some POSIX and BSD functionality
append_flags(CMAKE_C_FLAGS -D_DEFAULT_SOURCE)

# Re-defined to benefit from expanding macros in gdb
set(CMAKE_C_FLAGS_DEBUG "-ggdb3")
# Re-defined, since default cmake release optimization level is O3
set(CMAKE_C_FLAGS_RELEASE "-O2 -DNDEBUG -ggdb3")

append_flags(CMAKE_C_FLAGS -Wall)
option(LUAJIT_ENABLE_WARNINGS "Build LuaJIT with warnings enabled" OFF)
if(LUAJIT_ENABLE_WARNINGS)
  append_flags(CMAKE_C_FLAGS
    -Wextra
    -Wdeclaration-after-statement
    -Wpointer-arith
    -Wredundant-decls
    -Wshadow
  )
endif()

# Auxilary flags for main targets (libraries, binaries)
append_flags(TARGET_C_FLAGS
  -D_FILE_OFFSET_BITS=64
  -D_LARGEFILE_SOURCE
  -U_FORTIFY_SOURCE
)

# Permanently disable the FFI extension to reduce the size of the LuaJIT
# executable. But please consider that the FFI library is compiled-in,
# but NOT loaded by default. It only allocates any memory, if you actually
# make use of it.
option(LUAJIT_DISABLE_FFI "FFI support" OFF)
if(LUAJIT_DISABLE_FFI)
  append_flags(TARGET_C_FLAGS -DLUAJIT_DISABLE_FFI)
endif()
set(LUAJIT_HAS_FFI NOT LUAJIT_DISABLE_FFI)

# Disable the JIT compiler, i.e. turn LuaJIT into a pure interpreter.
option(LUAJIT_DISABLE_JIT "JIT support" OFF)
if(LUAJIT_DISABLE_JIT)
  append_flags(TARGET_C_FLAGS -DLUAJIT_DISABLE_JIT)
endif()
set(LUAJIT_HAS_JIT NOT LUAJIT_DISABLE_JIT)

# Features from Lua 5.2 that are unlikely to break existing code are
# enabled by default. Some other features that *might* break some existing
# code (e.g. __pairs or os.execute() return values) can be enabled here.
# Note: this does not provide full compatibility with Lua 5.2 at this time.
option(LUAJIT_LUA52COMPAT "Compatibility with Lua 5.2" OFF)
if(LUAJIT_LUA52COMPAT)
  append_flags(TARGET_C_FLAGS -DLUAJIT_ENABLE_LUA52COMPAT)
endif()

# Some architectures (e.g. PPC) can use either single-number (1) or
# dual-number (2) mode. Uncomment one of these lines to override the
# default mode. Please see LJ_ARCH_NUMMODE in lj_arch.h for details.
set(LUAJIT_NUMMODE "" CACHE STRING "Switch to single-number or dual-number mode.")
set(LUAJIT_NUMMODE_VALUES 1 2)
# XXX: explicitly added empty string allows to disable this flag in GUI.
set_property(CACHE LUAJIT_NUMMODE PROPERTY STRINGS "" ${LUAJIT_NUMMODE_VALUES})

if(NOT LUAJIT_NUMMODE STREQUAL "")
  # Check that LUAJIT_NUMMODE value is correct
  # In CMake 3.5 we'll be able to use IN_LIST here
  list(FIND LUAJIT_NUMMODE_VALUES ${LUAJIT_NUMMODE} LUAJIT_NUMMODE_INDEX)
  if(LUAJIT_NUMMODE_INDEX EQUAL -1)
    message(FATAL_ERROR "LUAJIT_NUMMODE must be '1' for single-number mode or '2' for dual-number mode.")
  endif()
  append_flags(TARGET_C_FLAGS -DLUAJIT_NUMMODE=${LUAJIT_NUMMODE})
endif()

# Enable GC64 mode for x64.
option(LUAJIT_ENABLE_GC64 "GC64 mode for x64" OFF)
if(LUAJIT_ENABLE_GC64)
  append_flags(TARGET_C_FLAGS -DLUAJIT_ENABLE_GC64)
endif()

# Switch to harder (and slower) hash function when a collision chain in
# the string hash table exceeds certain length.
option(LUAJIT_SMART_STRINGS "Harder string hashing function" ON)
if(LUAJIT_SMART_STRINGS)
  append_flags(TARGET_C_FLAGS -DLUAJIT_SMART_STRINGS=1)
endif()

# XXX: Note that most of the options below are NOT suitable for benchmarking
# or release mode!

# Use the system provided memory allocator (realloc) instead of the
# bundled memory allocator. This is slower, but sometimes helpful for
# debugging. This option cannot be enabled on x64 without GC64, since
# realloc usually doesn't return addresses in the right address range.
# OTOH this option is mandatory for Valgrind's memcheck tool on x64 and
# the only way to get useful results from it for all other architectures.
option(LUAJIT_USE_SYSMALLOC "System provided memory allocator (realloc)" OFF)
if(LUAJIT_USE_SYSMALLOC)
  append_flags(TARGET_C_FLAGS -DLUAJIT_USE_SYSMALLOC)
endif()

# This define is required to run LuaJIT under Valgrind. The Valgrind
# header files must be installed. You should enable debug information, too.
# Use --suppressions=lj.supp to avoid some false positives.
option(LUAJIT_USE_VALGRIND "Valgrind support" OFF)
if(LUAJIT_USE_VALGRIND)
  append_flags(TARGET_C_FLAGS -DLUAJIT_USE_VALGRIND)
endif()

# This is the client for the GDB JIT API. GDB 7.0 or higher is required
# to make use of it. See lj_gdbjit.c for details. Enabling this causes
# a non-negligible overhead, even when not running under GDB.
option(LUAJIT_USE_GDBJIT "GDB JIT support" OFF)
if(LUAJIT_USE_GDBJIT)
  append_flags(TARGET_C_FLAGS -DLUAJIT_USE_GDBJIT)
endif()
# TODO: enable optional GDB JIT only for Linux. Consider the example below:
# if(LUAJIT_TARGET_OS STREQUAL "UJ_TARGET_LINUX")
#   option(LUAJIT_ENABLE_GDBJIT "Support for DWARF data for assembled traces" OFF)
# else()
#   set(LUAJIT_ENABLE_GDBJIT OFF)
# endif()
# if(LUAJIT_ENABLE_GDBJIT)
#   # NB! This macro needs to be defined in the root C flags because if we define
#   # it only in TARGET_C_FLAGS_LIST, targets buildvm and core will be built with
#   # different versions of struct GCtrace.
#   set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DLUAJIT_USE_GDBJIT")
# endif()

# Turn on assertions for the Lua/C API to debug problems with lua_* calls.
# This is rather slow -- use only while developing C libraries/embeddings.
option(LUAJIT_USE_APICHECK "Assertions for the Lua/C API" OFF)
if(LUAJIT_USE_APICHECK)
  append_flags(TARGET_C_FLAGS -DLUAJIT_USE_APICHECK)
endif()

# Turn on assertions for the whole LuaJIT VM. This significantly slows down
# everything. Use only if you suspect a problem with LuaJIT itself.
option(LUAJIT_USE_ASSERT "Assertions for the whole LuaJIT VM" OFF)
if(LUAJIT_USE_ASSERT)
  append_flags(TARGET_C_FLAGS -DLUAJIT_USE_ASSERT)
endif()

message(STATUS "!WIP: TARGET_C_FLAGS=${TARGET_C_FLAGS}")

# --- Main source tree ---------------------------------------------------------

add_subdirectory(src)
